---
title: "Statistical inference with general linear models and mixed models"
author: "Greg Maurer, Darren James"
date: '2022-06-19'
output:
    html_document:
      toc: true
---

```{r, setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


## Introduction

(@Greg @Darren - this is the old outline for the workshop, we can update this
or have this on the [workshop page](../workshops/20220628-ecology-short-course.Rmd)

Hypothesis testing is...

We will cover:

* P values
* Common pitfalls
* Making inferences
* Understanding approximations underlying the analysis approach
* Rencher & Schaalje P-value interpretations
* Information-theoretic approaches

### Our data and R packages

You will need to have the `car` package installed, which adds additional options
and specifications to fitted regression models, such as type-II and -III ANOVA 
output tables. You will also need `emmeans`, `multcomp`, and `multcompView`
for post-hoc comparisons of groups in fitted linear models, and `lme4` and
`lmerTest` to fit and test some mixed models.

Data for the exercises here come from the Jornada annual NPP data package on
EDI. You can learn more about this dataset on the [teaching datasets]('./teaching_datasets.Rmd#Teaching-dataset-1') page. To load the data we will first load the `tidyverse` and use its
`read_csv()` function to read in the data from EDI. Then we'll look at the
structure of this data.

```{r load_data, message=FALSE}
# Get tidyverse & the NPP data
library(tidyverse)

anpp <- read_csv('https://pasta.lternet.edu/package/data/eml/knb-lter-jrn/210011003/105/127124b0f04a1c71f34148e3d40a5c72')

str(anpp)
```

We have four columns: `year` is a number representing the year of observation, 
`zone` is a character representing one of the 5 major vegetation zones at the
Jornada, `site` is a string representing one of the 15 NPP study sites at the
Jornada, and `npp_g_m2` is our observed NPP value in $g\cdot m^{-2}$.

```{r}
# Then, make a summary figure
ggplot(anpp, aes(x = year, y = npp_g_m2, col = site, group = site)) +
  geom_line() +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5))
```

## Comparing two samples

```{r, include=FALSE}
##
## Comparing two samples
##
```

We commonly need to compare two samples from a set of observations. In this
lesson, we examine net primary production data (NPP) collected at the Jornada.
This dataset has been collected for over 3 decades, and as shown above, there is
significant variability from year to year. Lets begin by comparing observations
in two years only, 2019 and 2020, to see if they are markedly different using a 
t-test.

First, create a dataframe that is subset of our full `anpp` dataframe.

```{r}
# Create a 2-year data subset
anpp.19.20 <- anpp %>%
  dplyr::filter(year %in% 2019:2020)
```

In t-tests we are usually testing whether the mean of two groups is different. 
Lets look at some summary statistics from our two years of data first.

```{r}
# Summary statistics
anpp.19.20.stats <- anpp.19.20 %>%
  group_by(year) %>%
  summarise(n = n(),
            mean = mean(npp_g_m2),
            std.dev = sd(npp_g_m2)) %>%
  mutate(std.err = std.dev/sqrt(n))

anpp.19.20.stats
```

From this we see that the means for each year are offset, increasing by about 
19 $g\cdot m^{-2}$ from 2019 to 2020. There are also differences in the
variance around the means, which we see as different standard deviation and
error statistics.

For a t-test we first need to put data into "wide" form, with observations
for the different years in separate columns.

```{r}
# Spread to wide form
anpp.19.20.wide <- anpp.19.20 %>%
  spread(year, npp_g_m2)

head(anpp.19.20.wide)
```

Now do a t-test for differences in mean NPP in 2019 and 2020, using the
`t.test()` function.

```{r}
# A default 2-sample t-test in R
t.test(x = anpp.19.20.wide$`2019`, 
       y = anpp.19.20.wide$`2020`)
```

We see that the default here is a "Welch Two Sample t-test", which is
an unequal variance test. That means that the test is designed to account for 
differences in variance between the 2019 and 2020 sample. We'll see later that
testing two samples with different variances is something we could also do 
with a mixed model. This test tells us that there isn't a "significant"
difference in the means since the p-value is greater than 0.05, which is our
$\alpha$ value, or the threshold we use to reject the null hypothesis that the
two means are the same.

Lets look at some variations on the t-test. First, a standard Student's t-test
with equal, or pooled, variance.

```{r}
# t-test with equal variance
t.test(x = anpp.19.20.wide$`2019`, 
       y = anpp.19.20.wide$`2020`, 
       var.equal = TRUE)
```

This lowers the p-value a tad, but is that a good thing? We've pooled the
variance for 2019 and 2020, even though we saw from our summary statistics that
the variances might be unequal, i.e., the standard deviation of the 2020
observations are higher.

Next lets try a paired t-test, which assumes that the observations in each
sample are not independent. We know this is the case since we're measuring the 
same sites each year, and therefore comparing two samples of the same 
experimental or statistical units (sites). In a paired t-test, the question
becomes whether the difference between the two samples, 2019 and 2020
observations, is itself different than zero. Therefore, if we already know that
we have unequal variances in our samples, taking the difference is a quick way
to get around that issue.

```{r}
# Paired t-test
t.test(x = anpp.19.20.wide$`2019`, 
       y = anpp.19.20.wide$`2020`, 
       paired = TRUE)
```

We have a significant result here (p-value < 0.05) which tells us that we can
reject the null hypothesis that the difference between these two years of data
is equal to zero. So, NPP changed from 2019 to 2020.

We'll see later that this paired t-test can also be formulated as a mixed model.

## Interlude - how should we interpret p-values?

An opinionated section on hypothesis testing with p-values.

## Testing for unequal variance

```{r, include=FALSE}
##
## Testing for unequal variance
##
```

Lets take a slightly larger slice of our original dataset now and examine
changes in variance within it. We can create a new dataset with years 2017
to 2020.

```{r}
# Create a 4-year data subset
anpp.17.20 <- anpp %>%
  dplyr::filter(year %in% 2017:2020)
```

How would we test whether there are unequal variances within the samples we are
comparing? If we plot the data, we will see some visual cues. Boxplots are a
nice method for this.

```{r}
ggplot(anpp.17.20, aes(x = year, y = npp_g_m2, group = year)) +
  geom_boxplot()
```

With the two additional years, we can see that some years, namely 2017, have
much higher variance than others. We can use some additional tests to quantify
that range in variance. (@Darren -  I'm not sure what to say on these, and also
not sure why we need the car package)

To give us some access to tests we'll use, lets first load the `car` package.

```{r, message=FALSE}
library(car)
```

```{r}
bartlett.test(npp_g_m2 ~ year, data = anpp.17.20)
fligner.test(npp_g_m2 ~ year, data = anpp.17.20)
leveneTest(npp_g_m2 ~ as.factor(year), data = anpp.17.20) # from car package
```

Each of these tests appears to reject the null hypothesis that observations
occurring in these four years have the same variance.

## Comparing samples with general linear models

```{r, include=FALSE}
##
## Comparing samples with general linear models
##
```

Comparing the mean of different samples, as we have done with t-tests, is also
possible using *General linear models*, a class of procedures often used in
standard statistics, including linear regression, one- and two-way analysis
of variance (ANOVA), and analysis of covariance (ANCOVA). All of these are
variations of "straight-line-fitting" statistics, and `R` uses the `lm()`
function for all these procedures. Instead of comparing sample means
directly, we are essentially comparing best-fit lines drawn between the mean
values of the samples.

Lets go back to our 2019 and 2020 dataframe and compare the general linear
models to the t-tests we did earlier in the lesson. A mean comparison test can
be done as a linear regression, using `lm` directly. We will fit a model and
then ask for summary results.

```{r}
# Two-sample mean comparison using a linear regression model
lm.ttest <- lm(npp_g_m2 ~ year, data = anpp.19.20)
summary(lm.ttest)
```

We get quite a few details on the linear model fit here, and see that we have
estimated the same difference in means and the same p-value as we had in the
earlier equal-variance two-sample t-test.

If we want to look at how this model is being fit visually, we can make a plot
using `ggplot`, which allows us to fitted models to a plot with `geom_smooth`.
We need to specify the type of model as "lm" to get a linear model.

```{r}
ggplot(data=anpp.19.20, aes(x=year, y=npp_g_m2)) +
  geom_point() +
  geom_smooth(method="lm")
```

Notice the difference in the means, represented by the slope of the line, and
the difference in the variance (vertical range of the points) between the 2019 
and 2020 samples.

We can also compare the means using one-way ANOVA. The function to do this is
`aov()`, but under the hood this is really just fitting an `lm` model again,
which we can see by looking at the function documentation.

```{r, message=FALSE}
?aov
```

One nuance here is that when given numerical predictor variables, like `year`,
`lm` interprets these as a continuous variable. For ANOVA, we aim to analyze
differences between discrete categories, so we should make sure we are using a
`factor`, which is how `R` represents categorical variables. Lets convert `year`
to a factor first.

```{r}
anpp.19.20.f <- anpp.19.20
anpp.19.20.f$year <- factor(anpp.19.20.f$year)
```

Now we can fit the ANOVA model using `aov()`, first specifying the linear model
and dataframe to use, and then ask R for summary statistics.

```{r}
# One-way ANOVA equivalent to the 2-sample t-test
aov.ttest <- aov(npp_g_m2 ~ year, data = anpp.19.20.f)
summary(aov.ttest)
car::Anova(lm.ttest, type = "III") # Not clear on difference in outputs, p value is same.
```

Notice that here, and when we used `lm`, our hypothesis test results were the 
same as with the unpaired, equal-variance, two sample t-test that we tried
earlier. This suggests that by default, `lm` is making some assumptions that
our observations are independent. We already know that they aren't. Later, we'll
see some ways to account for this.

When we have multiple categories in our data, we can do a multi-way ANOVA by 
adding additional factors to the model. In our case we have aother categorical
variable, called `zone`, that assigns each NPP site to one of the five major
vegetation zones at Jornada. Since this is a character column `lm`, or `aov`, 
will interpret that column as a factor, and we don't need to convert it first.

```{r}
# Two-way ANOVA using year and vegetation zone
aov.2way <- aov(npp_g_m2 ~ year + zone, data = anpp.19.20.f)
summary(aov.2way)
```

In our two-way ANOVA, we see that vegetation zone has a p-value below 0.05,
which suggests that we might be able to reject the null hypothesis that all the
vegetation zones have the same mean NPP value in 2019 and 2020.

This is all instructive, but we know that we should be using a paired model
since our observations are not independent. In ANOVA, the term for this is
*repeated measures*.  To use repeated measures with `aov` we must add an "Error"
term to our model that partitions the observed variance between years according
to `site`, since `site` is our experimental unit or subject.

```{r}
# One-way, repeated measures ANOVA using year and site
aov.1way.rm <- aov(npp_g_m2 ~ year + Error(site/year),
                   data = anpp.19.20.f)
summary(aov.1way.rm)
```

Somewhat unsurprisingly here, we have gotten the same result as with the earlier
paired t-test. This also suggests that we can use linear models to partition 
variance according to the groups in our data. Why would we want to do that?

(@Greg @Darren - this seems like a good place to jump to 
mixed models, but do we need a better explanation here first...?).

## Unequal variance in ANOVA

```{r}
# ANOVA with 2017 data
# Differences between vegetation zones
anpp.2017 <- anpp %>%
  dplyr::filter(year == "2017") %>%
  mutate(zone = factor(zone))

# Graph data with boxplots
ggplot(anpp.2017, aes(x = zone, y = npp_g_m2, fill = zone)) +
  geom_boxplot()

# Run ANOVA with lm()
lm.ANOVA <- lm(npp_g_m2 ~ zone, data = anpp.2017) 
# Diagnostics
plot(lm.ANOVA)


# Test for normality of residuals
resid(lm.ANOVA) %>% shapiro.test()

# Look at model results.  Note that this reports Type I Sums of Squares
summary(lm.ANOVA)
# Note: recommend using Type III F tests from car::Anova()
# In this case they are the same as Type I
car::Anova(lm.ANOVA, type = "III", test.statistic = "F")

library(emmeans)
# Least squares means (estimated marginal means)
emmeans(lm.ANOVA, ~ zone)

# Notice there are n*(n-2)/2 possible pairwise comparisons
# Pairwise comparisons of least squares means
contrast(emmeans(lm.ANOVA, specs= ~zone), method = "pairwise")

# Letter separations (efficient way to display)
emmeans(lm.ANOVA, ~ zone) %>%
  multcomp::cld(Letters = LETTERS)

# Problem: emmeans switches to Sidak when adjust = "Tukey" is specified
emmeans(lm.ANOVA, ~ zone, adjust = "Tukey") %>%
  multcomp::cld(Letters = LETTERS)

# Compare results from Tukey and Scheffe
emmeans.Tukey <- emmeans(lm.ANOVA, specs = ~ zone) %>% 
  multcomp::cld(Letters = LETTERS) %>%
  as_tibble() %>%
  mutate(method = "Tukey")

emmeans.Scheffe <- emmeans(lm.ANOVA, specs = ~ zone) %>% 
  multcomp::cld(Letters = LETTERS, adjust = "scheffe") %>%
  as_tibble() %>%
  mutate(method = "Scheffe")

# Look at least squares means and 95% confidence intervals
bind_rows(emmeans.Tukey, emmeans.Scheffe) %>%
  mutate(.group = trimws(.group)) %>%
  ggplot(aes(x = zone, y = emmean, col = zone)) +
  geom_point() +
  geom_errorbar(aes(ymin=lower.CL, ymax=upper.CL), width=.1) +
  geom_text(aes(x = zone, y = emmean, label = .group), hjust = - 0.5, show.legend = FALSE) +
  facet_wrap(~ method, ncol = 1) +
  ggtitle("2017 ANPP by Vegetation Zone", 
          subtitle = "means with the same letter are not different at alpha = 0.05") +
  ylab("Model-based mean ANPP (g/m^2) +/- 95% CI")


# Look at least squares means and standard errors
# This kind of figure is the one most commonly reported in scientific papers
bind_rows(emmeans.Tukey, emmeans.Scheffe) %>%
  mutate(.group = trimws(.group)) %>%
  ggplot(aes(x = zone, y = emmean, col = zone)) +
  geom_point() +
  geom_errorbar(aes(ymin=emmean-SE, ymax=emmean+SE), width=.1) +
  geom_text(aes(x = zone, y = emmean, label = .group), hjust = - 0.5, show.legend = FALSE) +
  facet_wrap(~ method, ncol = 1) +
  ggtitle("2017 ANPP by Vegetation Zone", 
          subtitle = "means with the same letter are not different at alpha = 0.05") +
  ylab("Model-based mean ANPP (g/m^2) +/- S.E.")
```



## Into the wilderness with linear mixed models

```{r, include=FALSE}
##
## Into the wilderness with linear mixed models
##
```

```{r}
library(nlme)
library(lme4)

# Repeated measures: 2017-2020
# Compare Annual ANPP between 2019 and 2020
anpp.2017.2020 <- anpp %>%
  dplyr::filter(year %in% 2017:2020) 

# Plot the data
ggplot(anpp.2017.2020, aes(x = year, y = npp_g_m2, col = zone, group = site)) +
  geom_point() +
  geom_line(linetype="dashed", size = .05) +
  scale_x_continuous(breaks = 2017:2020)

# Variance is highest in 2017
anpp.2017.2020 %>%
  group_by(year) %>%
  summarise(std.dev = sd(npp_g_m2))

# Fit a repeated measures model (correlated errors with unstructured structure)
model.un <- gls(npp_g_m2 ~ zone*factor(year),
                corSymm(form = ~ 1 | site),
                weights=varIdent(form=~1|factor(year)),
                data = anpp.2017.2020)

# Fit a repeated measures model (correlated errors with autoregressive covariance structure)
model.ar <- gls(npp_g_m2 ~ zone*factor(year),  
                corAR1(form = ~ 1 | site), 
                weights=varIdent(form=~1|factor(year)), 
                data = anpp.2017.2020)

AIC(model.un)
AIC(model.ar)

# AR actually fits better than Unstructured
# Try using only 2 varaiance: parameters: one for 2017 when the varance in high 
# Set 2018, 2019, 2020 variances to be estimated as the same 

anpp.2017.2020 <- anpp.2017.2020 %>%
  mutate(anpp_level = if_else(year == 2017, "high", "low")) 


model.ar <- gls(npp_g_m2 ~ zone*factor(year),  
                      corAR1(form = ~ 1 | site), 
                      weights=varIdent(form=~1|anpp_level), 
                      data = anpp.2017.2020)

AIC(model.ar)

emmeans(model.ar, ~ zone*factor(year), lmer.df = "kenward-roger") 

# It's a little difficult to extract the correlationa and variance parameters
coef(model.un$modelStruct$corStruct, uncons = FALSE, allCoef = TRUE)
coef(model.un$modelStruct$varStruct, uncons = FALSE, allCoef = TRUE) 

# Compare model results from 3 different mixed models specified similarly
# Note differnt spceficiations in the funtion arguments

# R-side model from nlme::gls()
model.ar.level.gls <- gls(npp_g_m2 ~ zone*factor(year),  
                          corAR1(form = ~ 1 | site), 
                          weights=varIdent(form=~1|anpp_level), 
                          data = anpp.2017.2020,
                          method = 'REML')

# G-side model from nlme::lme()
model.ar.level.lme <- lme(fixed = npp_g_m2 ~ zone*factor(year),  
                          random = ~ 1 | site,
                          weights = varIdent(form = ~ 1 | anpp_level),
                          data = anpp.2017.2020,
                          method = 'REML')

# G-side model from lme4::lmer()
model.ar.level.lmer <- lmer(npp_g_m2 ~ zone*factor(year) + 
                              (anpp_level | site),
                            data = anpp.2017.2020 %>%
                              mutate(anpp_level = factor(anpp_level),
                                     site = factor(site)))

AIC(model.ar.level.gls)
AIC(model.ar.level.lme)
AIC(model.ar.level.lmer)

mod.compare <- emmeans(model.ar.level.gls, ~zone*factor(year), lmer.df = "satterthwaite") %>%
  multcomp::cld(alpha = 0.05, Letters = LETTERS) %>%
  mutate(model = "gls") %>%
  bind_rows(emmeans(model.ar.level.lme, ~zone*factor(year), lmer.df = "satterthwaite") %>%
              multcomp::cld(alpha = 0.05, Letters = LETTERS) %>%
              mutate(model = "lme")) %>%
  bind_rows(emmeans(model.ar.level.lmer, ~zone*factor(year), lmer.df = "satterthwaite") %>%
              multcomp::cld(alpha = 0.05, Letters = LETTERS) %>%
              mutate(model = "lmer"))

# Compare means ... should all be the same
mod.compare %>%
  dplyr::select(zone, year, emmean, model) %>%
  spread(model, emmean)

# Compare standard errors
mod.compare %>%
  dplyr::select(zone, year, SE, model) %>%
  spread(model, SE)

# Compare mean comparison results
mod.compare %>%
  dplyr::select(zone, year, .group, model) %>%
  spread(model, .group)

pd <- position_dodge(0.5)
ggplot(mod.compare, aes(x = year, y = emmean, group = zone, colour = zone)) +
  geom_point(position=pd) +
  geom_line(position=pd) +
  geom_errorbar(aes(ymin = emmean - SE , ymax = emmean + SE), width=0.2, position=pd) +
  geom_text(aes(label = .group, y = emmean), 
            position = pd, hjust = -0.1, col = "black", size = 2.5) +
  facet_wrap(~ model, ncol = 1, strip.position = "right") +
  theme(legend.position = "top")

```