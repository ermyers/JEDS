---
title: "Git and GitHub for researchers"
author: "Greg Maurer"
date: '2022-09-01'
output:
  #ioslides_presentation
    html_document:
      toc: true
#toc: yes
---

```{r, setup1, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{bash, setup2, include=FALSE}
mkdir ~/awesomeproject
touch ~/awesomeproject/data.csv ~/awesomeproject/analysis_script_final.1.R \
~/awesomeproject/analysis_script_final.R ~/awesomeproject/analysis_script_v1.R \
~/awesomeproject/analysis_script_v2.R ~/awesomeproject/analysis_script_v3_MLtest.R \
~/awesomeproject/analysis_script_v3.R ~/awesomeproject/analysis_script.R

mkdir ~/awesomeproject_git
touch ~/awesomeproject_git/analysis_script.R ~/awesomeproject_git/data.csv
cd ~/awesomeproject_git
git init
echo "This is my script" >> analysis_script.R
git add analysis_script.R
git commit -m "Initial commit - add analysis script"
echo "Add a linear model" >> analysis_script.R
git add analysis_script.R
git commit -m "Fit linear model to the data"
echo "Add a polynomial model" >> analysis_script.R
git add analysis_script.R
git commit -m "Fit polynomial model"
echo "Make some figures" >> analysis_script.R
git add analysis_script.R
git commit -m "Statistics and figures for report 1"
```

# 1. Getting to know git

## What is `git`?

* free & open-source distributed version control system (DVCS)
* first authored by Linus Torvalds for development of the Linux kernel
* very widely used to "version control" software dev projects
* excels at tracking changes to computer code files (plain text)
* good for collaborative workflows

## Why use version control as a researcher? {.build}

* scientists write lots of computer code and documentation
* we revise things often
* paths of inquiry get abandoned, or revisited later
* scientists work collaboratively
* research projects evolve and diversify with time

Research can become a "garden of forking paths"

**Version control records changes and helps manage the complexity**

## Inside a "simple" data analysis project

```{bash, awesomeproject}
ls ~/awesomeproject/
```

The researcher has gone down different paths:

* linear, polynomial, and machine learning models
* input from a collaborator
* a "final product" for a report or paper

Each resulted in a different file.

## `git` simplifies things 

```{bash, awesomeproject_git}
# The -a lists hidden files like .git
ls -a ~/awesomeproject_git/
```

This is a _`git` repository_ for the same analysis project

* There is only one script (`analysis_script.R`)
* All changes to the script (and other files) are recorded in the `.git`
directory.

## What is recorded in `.git/`?

**`git` keeps track of what changed, who changed it, when it changed, and why* **
![Schematic of a git-based workflow](img/git_diagram1.png)
\ \ \ \ \ \ \ \* _as long as you tell it to_

## Some terminology

>- ***repository***: a directory with a history of changes recorded by `git`,
meaning it must contain a `.git` subdirectory.
>- ***commit***: `git`'s basic unit of version control that records *exactly* which
lines changed in which files, and how, plus annotations about person, time, etc.
>- ***version***: the state of repository files produced by a particular line of
development that includes one or more commits to the repository
>- ***branch***: a version of repository files that diverges (with separate
commits) from the main line of development (the `main` branch) in the repository
>- ***fork***: a complete copy of a `git` repository that then undergoes
divergent changes from the original

## An annotated list of "commits" {.smaller}

```{bash, commits}
git -C ~/awesomeproject_git/ log
```


# 2. Now try some `git` basics

## Finding and configuring `git`

We will do this in the system shell. So, open a terminal with `bash`, `zsh`,
or another shell (you may have installed one with `git` on windows), and then
type the following command.

```{bash, check_for_git}
git --version
```
If you got the output above, or similar. You have `git` installed. If you didn't
you will need to return to the [setup instructions](../html/setup.html) and
install `git` for your system.

If `git` is newly installed on your system, you probably need to configure a
couple of things. As you start using `git` commands, it helps to know that they
usually follow a `git verb options` pattern, where `verb` is the action you need
to take, and `options` give some specifics of how to do the action. For 
configuration, lets first, tell `git` who you are.

```{bash, tell_git_who_u_are, eval=FALSE}
git config --global user.name "Marie Curie"
git config --global user.email "marie@sorbonne.fr"
```

There are some differences in how computer platforms handle line endings
in text files. Correspondingly, you will want to tell `git` how to do this too,
and the configuration for MS Windows machines will be different than for Mac and
Linux machines. For Mac and Linux, the recommended setting is:

```{bash, line-endings_mac, eval=FALSE}
git config --global core.autocrlf input
```

And for Windows it is:

```{bash, line-endings_win, eval=FALSE}
git config --global core.autocrlf true
```

Since we'll be using GitHub, which names its repository main branches `main`,
we should make sure our `git` follows the same convention.

```{bash, config_main, eval=FALSE}
git config --global init.defaultBranch main
```

Finally, you might also want to configure `git` to use your favorite text editor
for writing commit messages. More information about that [here](https://swcarpentry.github.io/git-novice/02-setup/index.html).

You can show your `git` configurations anytime with `git config --list` command.

### Making your first repository

Now lets make a new directory and add a text file to it. We will turn this into
a `git` repository in a moment.

```{bash, start_repo}
mkdir ~/my_repo
touch ~/my_repo/script.R
cd ~/my_repo
```
```{r, setup3, include=FALSE}
# Have to change working directory
knitr::opts_knit$set(root.dir = '~/my_repo')
#setwd('~/my_repo')
```

Now that we are in our project directory, lets make it a repository

```{bash, init_repo}
git init
```

We can use the `ls -a` shell command to see if we made a `.git` directory to
to store the changes we will make to our files.

```{bash, list_repo}
ls -a
```
Now lets ask `git` to tell us the status of our repository.

```{bash, repo_status}
git status
```

We are on the `main` branch, there are no commits yet, and there is a file that
we made - `script.R` - that is not being tracked. 

### Adding files and tracking changes

Lets tell `git` to track that file. We do that with the `add` verb, which 
"stages" the file to be added to a new commit.

```{bash, stage_file}
git add script.R
```

If we want to check the status now, we'll see that `script.R` is staged to be 
added as a new file, under the "Changes to be committed" list.

```{bash, status_staged}
git status
```

This staging step lets you compose multiple changes to your repository files 
into a group of updates to your history (sometimes called a change-set). When
we are ready to add these changes, for us just one new file, to our `git`
repository, we `commit` the changes to the repository, which will store the
initial version of our file in `git`'s history.

```{bash, commit_file}
git commit -m 'Adding the first R script'
```

Sooner or later we'll add something to this file, and we'll want to commit those
changes to the repository as well. **Open up your `script.R` file in a text editor
and add a couple lines of "code", then save this file again**. After it is saved
you can check your repository status with `git status` again.

```{bash, add_lines, include=FALSE}
echo "Load the data..." >> script.R
echo "Fit a linear model..." >> script.R
```

```{bash, status_script}
git status
```

This tells us that `script.R` was modified, but those changes haven't been
staged yet To get line-by-line details about what changed in your file, you can
"diff" the file to show the difference between the last committed version, and
what it looks like after you added some code.

```{bash, diff_script}
git diff script.R
```

The lines prepended with a `+` show what has been added since the last commit.
Lines starting with `-` would show you what was removed, but we haven't removed
anything. This seems like a reasonable change, so lets stage the updated file
with `git add` and add it to our repository with `git commit`.

```{bash, commit_script}
git add script.R
git commit -m 'I updated the script with 2 lines'
```

Take note that when you commit something to your repository's history it is wise
to explain what was changed using a "commit message" That is what we are doing
with the `-m` option followed by a quoted message. Commit messages are invaluable
in helping you understand how and why your repository is changing, so before
you commit something, put a little thought into how you will describe the changes.

Lets take a quick look at our history now:

```{bash, log_after_changes}
git log
```

We can see our progress so far. There are two commits, with the first adding the
new `script.R` file, and the second one adding a couple of lines to it.

# 3. Starting with GitHub

## What is GitHub?

* <https://github.com>
* Software development and collaboration platform
* A host for `git` repositories with web-based tools for working in a highly
networked, collaborative way
* Owned by Microsoft now
* Very widely used

## How to use GitHub

**Interact with the GitHub website with a browser**

* For example, [this tutorial](https://github.com/jornada-im/JEDS/tree/main/episodes) is in a repository on GitHub.
* With an account you can create `git` repositories and much more.

**Clone or sync changes (`push` and `pull`) with GitHub repositories using `git`**

```{bash, clone_GitHub, exec=FALSE}
git clone https://github.com/jornada-im/JEDS.git
```

**GitHub also has a bunch of APIs, a command-line tool, GitHub Desktop...**

## When should researchers use GitHub?

* If you do scientific computing/software development
* For collaborative...
  - data analysis
  - writing
  - project management
  - teaching
  - (and computing/software dev)
* Personal/professional/project/educational websites
* Automating tasks

# 4. Basic GitHub

Lets create a repository on GitHub, initialize it with some files, and then use
our local `git` tools to pull the new repository to our computer. We can then
make some changes and push them back to GitHub.

```{r, setup4, include=FALSE}
knitr::opts_knit$set(root.dir = '~/GitHub/JEDS/episodes')
#setwd('~/GitHub/JEDS/episodes')
```

```{r, cleanup_r, include=FALSE}
unlink('~/awesomeproject', recursive=TRUE)
unlink('~/awesomeproject_git', recursive=TRUE)
unlink('~/my_repo', recursive=TRUE)
```

```{bash, cleanup, include=FALSE, exec=FALSE}
#rm -r ~/awesomeproject;
#rm -r ~/awesomeproject_git;
#rm -r ~/my_repo;
```
